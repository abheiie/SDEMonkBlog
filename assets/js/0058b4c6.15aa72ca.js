"use strict";(self.webpackChunksde_monk_blog=self.webpackChunksde_monk_blog||[]).push([[849],{6164:e=>{e.exports=JSON.parse('{"version":{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"tutorialSidebar":[{"type":"category","label":"OOP Principles","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Overview","href":"/docs/OOP/overview","docId":"OOP/overview","unlisted":false},{"type":"link","label":"Encapsulation","href":"/docs/OOP/encapsulation","docId":"OOP/encapsulation","unlisted":false},{"type":"link","label":"Abstraction","href":"/docs/OOP/abstraction","docId":"OOP/abstraction","unlisted":false},{"type":"link","label":"Inheritance","href":"/docs/OOP/inheritance","docId":"OOP/inheritance","unlisted":false},{"type":"link","label":"Polymorphism","href":"/docs/OOP/polymorphism","docId":"OOP/polymorphism","unlisted":false}],"href":"/docs/docs/oop"},{"type":"category","label":"SOLID Principles","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Overview","href":"/docs/SOLID/overview","docId":"SOLID/overview","unlisted":false},{"type":"link","label":"Single-Responsibility Principle (SRP)","href":"/docs/SOLID/single-responsibility-principle","docId":"SOLID/single-responsibility-principle","unlisted":false},{"type":"link","label":"Open-Closed Principle (OCP)","href":"/docs/SOLID/open-close-principle","docId":"SOLID/open-close-principle","unlisted":false},{"type":"link","label":"Liskov Substitution Principle (LSP)","href":"/docs/SOLID/liskov-substitution-principle","docId":"SOLID/liskov-substitution-principle","unlisted":false},{"type":"link","label":"Interface Segregation Principle (ISP)","href":"/docs/SOLID/interface-segregation-principle","docId":"SOLID/interface-segregation-principle","unlisted":false},{"type":"link","label":"Dependency Inversion Principle (DIP)","href":"/docs/SOLID/dependency-inversion-principle","docId":"SOLID/dependency-inversion-principle","unlisted":false}],"href":"/docs/docs/solid"},{"type":"category","label":"Design Patterns","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Overview","href":"/docs/Design Patterns/overview","docId":"Design Patterns/overview","unlisted":false}],"href":"/docs/docs/design-patterns"}]},"docs":{"Design Patterns/overview":{"id":"Design Patterns/overview","title":"Overview","description":"Coming Soon","sidebar":"tutorialSidebar"},"OOP/abstraction":{"id":"OOP/abstraction","title":"Abstraction","description":"\u2705 What is Abstraction?","sidebar":"tutorialSidebar"},"OOP/encapsulation":{"id":"OOP/encapsulation","title":"Encapsulation","description":"What is Encapsulation?","sidebar":"tutorialSidebar"},"OOP/inheritance":{"id":"OOP/inheritance","title":"Inheritance","description":"What is Inheritance?","sidebar":"tutorialSidebar"},"OOP/overview":{"id":"OOP/overview","title":"Overview","description":"What is OOP?","sidebar":"tutorialSidebar"},"OOP/polymorphism":{"id":"OOP/polymorphism","title":"Polymorphism","description":"What is Polymorphism?","sidebar":"tutorialSidebar"},"SOLID/dependency-inversion-principle":{"id":"SOLID/dependency-inversion-principle","title":"Dependency Inversion Principle (DIP)","description":"- High-level modules should not depend on low-level modules. Both should depend on abstractions.","sidebar":"tutorialSidebar"},"SOLID/interface-segregation-principle":{"id":"SOLID/interface-segregation-principle","title":"Interface Segregation Principle (ISP)","description":"- Clients should not be forced to depend on interfaces they do not use.","sidebar":"tutorialSidebar"},"SOLID/liskov-substitution-principle":{"id":"SOLID/liskov-substitution-principle","title":"Liskov Substitution Principle (LSP)","description":"- Subtypes must be substitutable for their base types without altering the correctness of the program.","sidebar":"tutorialSidebar"},"SOLID/open-close-principle":{"id":"SOLID/open-close-principle","title":"Open-Closed Principle (OCP)","description":"- Software entities (classes, modules, functions, etc.) should be open for extension but closed for modification.","sidebar":"tutorialSidebar"},"SOLID/overview":{"id":"SOLID/overview","title":"Overview","description":"The SOLID principles are a set of five design principles that help software developers create more maintainable, understandable, and flexible software systems. The principles are:","sidebar":"tutorialSidebar"},"SOLID/single-responsibility-principle":{"id":"SOLID/single-responsibility-principle","title":"Single-Responsibility Principle (SRP)","description":"- A class should have only one reason to change, meaning it should handle only one responsibility. If it does more, split those tasks into separate classes.","sidebar":"tutorialSidebar"}}}}')}}]);